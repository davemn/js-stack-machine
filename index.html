<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="shortcut icon" href="img/favicon.png">
    <title>JS Emulator</title>
    <!-- Bootstrap core CSS + customizations -->
    <link rel="stylesheet" type="text/css" href="index.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="bower_components/html5shiv/dist/html5shiv.js"></script>
    <script src="bower_components/respond/dest/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <section>
      <div class='container'>
        <div class='row'>
          <div class='col-md-12'>
            <!-- <h1 class='text-center'>Stack Machine</h1> -->
          </div>
        </div>
        <div class='row'>
          <div class='col-md-6'>
            <!-- <h2 class='text-center'>Assembly</h2> -->
            <form id="assemble">
              <div class='editor-container'>
                <div id="editor-asm"></div>
              </div>
              <button type="submit" class="btn btn-primary btn-block">Assemble</button>
            </form>
            <table class="table" id="assemble-output">
              <thead>
                <tr>
                  <th>Line #</th>
                  <th>Message</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
          <div class='col-md-6'>
            <!-- <h2 class='text-center'>Memory</h2> -->
            <div class="input-group">
              <input type="text" class="form-control" placeholder="Append text to memory...">
              <span class="input-group-btn">
                <button class="btn btn-default" type="button">Append</button>
              </span>
            </div><!-- /input-group -->
            <div class="row">
              <div class="col-md-6">
                <div class="editor-container">
                  <div id="editor-mem"></div>
                </div>
              </div>
              <div class="col-md-6">
                <div class="editor-container">
                  <div id="editor-mem-ascii"></div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
    <!-- Placed at the end of the document so the pages load faster -->
    <script type="text/javascript" src="bower_components/jquery/dist/jquery.js"></script>
    <script type="text/javascript" src="bower_components/bootstrap/dist/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.0/ace.js" charset="utf-8"></script>
    <script>
      $(window).load(function() {
      
      });
      
      var Memory = {
        length: 65536, // max bytes addressable by 16-bit word, = 64K bytes
        bank: new ArrayBuffer(this.length),
      
        readWord: function(addr){
          if(addr < 0 || addr >= this.length )
            throw new Error('Memory access violation!');
            
          var view = new DataView(this.bank, addr, 2);
          return view.getUint16(0);
        },
        readByte: function(addr){
        
        },
        writeWord: function(addr, val){
          if(addr < 0 || addr >= this.length )
            throw new Error('Memory access violation!');
            
          var view = new DataView(this.bank, addr, 2);
          view.setInt16(0, val);
        },
        writeByte: function(addr, val){
        
        }
      };
      
      var Instruction = {
        IMM: 0x00, // immediate
        ADD: 0x01,
        SUB: 0x02,
        MUL: 0x03,
        DIV: 0x04,
        JMP: 0x05, // absolute address ...
        BEQ: 0x06,
        BNE: 0x07,
        LOD: 0x08,
        STO: 0x09,
        // TODO PC relative addressing?
        NOP: 0xff
      };
      
      var VM = {
        stack: [],
        stackMax: 128,
        
        push: function(val){
          if(this.stack.length >= this.stackMax)
            throw new Error('Stack overflow!');
        
          this.stack.push(val & 0xffff);
        },
        pop: function(){
          if(this.stack.length <= 0)
            throw new Error('Stack underflow!');
        
          var val = this.stack.pop();
          return (val & 0xffff);
        },
        
        interpret: function(bytecode){
          var instruction, next;
          var lhs, rhs;
          
          for(var i=0; i < bytecode.length; i++){
            if(i < 0 || i >= bytecode.length)
              throw new Error('Segmentation fault!');
            
            // force all instructions to 1 byte, and immediates / addresses to 2
            instruction = bytecode[i] & 0xff;
            if((i+1) < bytecode.length)
              next = bytecode[i+1] & 0xffff;
            else // must include else, so that previous 'next' val doesn't persist across instructions
              next = null;
            
            // check for well-formed instructions
            switch(instruction){
              case Instruction.IMM:
              case Instruction.JMP:
              case Instruction.BEQ:
              case Instruction.BNE:
              case Instruction.LOD:
              case Instruction.STO:
                if(next === null)
                  throw new Exception('Expected immediate / address!');
            }
            
            // execute instructions
            switch(instruction){
              default: // TODO must be at end of switch statement?
                throw new Exception('Unrecognized opcode!');
              case Instruction.NOP: 
                i++;
                break;
              case Instruction.IMM:
                this.push(next);
                i++;
                break;
              case Instruction.ADD:
                rhs = this.pop();
                lhs = this.pop();
                this.push(lhs + rhs);
                break;
              case Instruction.SUB:
                rhs = this.pop();
                lhs = this.pop();
                this.push(lhs - rhs);
                break;
              case Instruction.MUL:
                rhs = this.pop();
                lhs = this.pop();
                this.push(lhs * rhs);
                break;
              case Instruction.DIV:
                rhs = this.pop();
                lhs = this.pop();
                this.push(lhs/rhs | 0); // integer division, rounds towards 0 (unlike Math.floor)
                break;
              case Instruction.JMP:
                // addr = this.pop(); // would allow you to calculate jump addresses ... not needed
                i = next-1; // -1 since we're automatically incrementing i
                break;
              case Instruction.BEQ:
                rhs = this.pop();
                lhs = this.pop();
                if(lhs === rhs)
                  i = next-1;
                else
                  i++; // since we need to skip immediate value
                break;
              case Instruction.BNE:
                rhs = this.pop();
                lhs = this.pop();
                if(lhs !== rhs)
                  i = next-1; 
                else
                  i++;
                break;
              case Instruction.LOD:
                this.push(Memory.readWord(next));
                i++;
                break;
              case Instruction.STO:
                Memory.writeWord(next, this.pop());
                i++;
                break;
            }
          }
        }
      };
      
      var AssembleError = function(lineNumber, msg){
        this.lineNo = lineNumber;
        this.message = msg;
      }
      AssembleError.prototype.toString = function(){
        return 'LINE <'+this.lineNo+'> '+this.message;
      };
      
      function assemble(src){
        var bin = [];
        var err = [];
      
        var lines = src.split('\n');
        var line, clean, mnemonic, immediate;
        
        for(var i=0; i < lines.length; i++){
          line = lines[i];
          clean = line.replace(/[^A-Za-z0-9- ]/g, '');
          clean = clean.trim();
        
          if(clean.length === 0) // ignore blank lines
            continue;
          if(clean.length === 3) {
            mnemonic = clean.toUpperCase(); // instruction mnemonic
            if(!(mnemonic in Instruction)){
              err.push(new AssembleError(i+1, 'Unknown opcode: "'+mnemonic+'".'));
              continue;
            }
            
            // check for missing argument to multi-byte instructions
            switch(Instruction[mnemonic]){
              case Instruction.IMM:
              case Instruction.JMP:
              case Instruction.BEQ:
              case Instruction.BNE:
              case Instruction.LOD:
              case Instruction.STO:
                err.push(new AssembleError(i+1, 'Expected immediate / address for opcode: "'+mnemonic+'".'));
                continue;
            }
          
            bin.push(Instruction[mnemonic]);
          }
          else {
            var tokens = /^([A-Za-z]{3})\s+(.*)$/g.exec(clean);
            
            if(tokens === null){
              err.push(new AssembleError(i+1, 'Bad instruction format: "'+line+'".'));
              continue;
            }

            // Check that the opcode actually exists
            mnemonic = tokens[1].toUpperCase();
            if(!(mnemonic in Instruction)){
              err.push(new AssembleError(i+1, 'Unknown opcode: "'+mnemonic+'".'));
              continue;
            }
            
            if(tokens[2].search(/^(-?0x[0-9A-Fa-f]+|-?\d+)$/g) === -1){
              err.push(new AssembleError(i+1, 'Bad immediate format: "'+tokens[2]+'".'));
              continue;
            }
          
            immediate = parseInt(tokens[2]);
            
            switch(Instruction[mnemonic]){
              case Instruction.NOP:
              case Instruction.ADD:
              case Instruction.SUB:
              case Instruction.MUL:
              case Instruction.DIV:
                // single-byte instruction
                err.push(new AssembleError(i+1, 'Immediate not allowed for opcode: "'+mnemonic+'".'));
                continue;
            }
            
            // Signed 16 bits: -0x8000 to 0x7fff. Still want to permit unsigned (absolute) addresses.
            if(immediate < -0x8000 || immediate > 0xffff){
              err.push(new AssembleError(i+1, 'Immediate value will not fit in word (16 bits): "'+immediate+'".'));
              continue;              
            }
                        
            bin.push(Instruction[mnemonic]);
            bin.push(immediate);
          }
        }
        if(err.length !== 0)
          throw err;
          
        return bin;
      }
      
      /** 
       * Find the length, in bytes, of the given program.
       * Program is assumed to be an untyped JS array of 
       * integers.
       */
      function calcLen(program){
        var byteCount = 0;
        var hasImm = false;
        
        for(var i=0; i < program.length; i++){
          if(hasImm){
            byteCount+=2;
            hasImm = false;
            continue;
          }

          switch(Instruction[program[i]]){
            case Instruction.IMM:
            case Instruction.JMP:
            case Instruction.BEQ:
            case Instruction.BNE:
            case Instruction.LOD:
            case Instruction.STO:
              // multi-byte instructions
              hasImm = true;
          }
          
          byteCount++;
        }
        
        return byteCount;
      }
            
      function stringSplice(str, idx, count, add){
        return str.slice(0,idx) + (add || '') + str.slice(idx+count);
      }
      
      function stringWrap(str, colLen){
        var wrapArr = str.match(new RegExp('.{1,'+colLen+'}','g')) || [];
        var wrap = wrapArr.reduce(function(prev,cur){
          if(prev.length === 0)
            return cur;
          return prev + '\n' + cur;
        },'');
        
        return wrap;
      }
      
      // Pad a string with the PADWITH characters, to a length 
      // that is a multiple of MULTIPLE.
      function stringRPadToMultiple(str, multiple, padWith){
        var strPadded;
        var noPadding = (str.length % multiple) === 0;
        
        if(noPadding)
          strPadded = str;
        else {
          var paddedLength = str.length + multiple - (str.length % multiple);
          strPadded = (str + Array(multiple+1).join(padWith)).substring(0,paddedLength);
        }
        
        return strPadded;
      }
      
      $(document).ready(function(evt) {
        // - Initialize assembly program editor ---
        var Range = ace.require('ace/range').Range;
        var Document = ace.require('ace/document').Document;
        
        var editor = ace.edit('editor-asm');
        editor.setTheme('ace/theme/eclipse');
        editor.getSession().setMode('ace/mode/assembly_x86');
        
        editor.setShowPrintMargin(false);
				editor.getSession().setTabSize(2);
				editor.getSession().setUseSoftTabs(true);
        
        // - Initialize memory editor ---
        var memGui = ace.edit('editor-mem');
        
        // memGui.getSession().setMode('ace/mode/assembly_x86');
        memGui.setShowPrintMargin(false);
				memGui.getSession().setTabSize(2);
				memGui.getSession().setUseSoftTabs(true);
        memGui.$blockScrolling = Infinity; // suppress warnings about scrolling
        
        // custom gutter, ala http://stackoverflow.com/questions/28311086/modify-the-gutter-of-ajax-org-cloud9-editor-ace-editor
        memGui.session.gutterRenderer = {
          getWidth: function(session, lastLineNumber, config) {          
            return 4 * config.characterWidth;
          },
          getText: function(session, row) {
            // Convert to padded hexadecimal
            var hex = row.toString(16).toUpperCase();
            return ('0000'+hex).substring(hex.length);
          }
        };
        
        // - Initialize ASCII memory editor ---
        var asciiMemGui = ace.edit('editor-mem-ascii');
        
        asciiMemGui.setShowPrintMargin(false);
				asciiMemGui.getSession().setTabSize(2);
				asciiMemGui.getSession().setUseSoftTabs(true);
        asciiMemGui.renderer.setShowGutter(false);
        asciiMemGui.$blockScrolling = Infinity; // suppress warnings about scrolling
        
        // ===
        
        // Modify the ASCII view when the hex view changes
        $('#editor-mem-ascii').on('editor-sync', function(evt, cursor, charCode){
          // console.log(cursor);
          // console.log(charCode);
        
          // cursor = position of cursor before last edit
          var asciiCol = Math.floor(cursor.column/2);
          
          var oldDoc = asciiMemGui.getValue();
          oldDoc = oldDoc.replace(/\n/g,''); // remove newlines if this is a multiline input
          
          var cleanInput = null;
          if(charCode < 97 || charCode > 122)
            cleanInput = '.';
          else
            cleanInput = String.fromCharCode(charCode);
          
          var newDoc = stringSplice(oldDoc, (cursor.row*8)+asciiCol, 1, cleanInput);
          var newDocPadded = stringRPadToMultiple(newDoc, 8, '.');
          var newDocWrap = stringWrap(newDocPadded, 8);
          
          asciiMemGui.setValue(newDocWrap, 1); // set the document text to the spliced string, and move the cursor to the end
          
          // Move the cursor to the new edit point
          
          asciiMemGui.clearSelection();
          if(asciiCol === 8){
            asciiMemGui.scrollToLine(cursor.row + 1)
            asciiMemGui.moveCursorTo(cursor.row+1, 1); // row, col
          }
          else {
            asciiMemGui.scrollToLine(cursor.row)
            asciiMemGui.moveCursorTo(cursor.row, asciiCol+1);
          }
        });
        
        // Substitute chars invalid for hex view, wrap hex view to 16 columns
        $('#editor-mem').on('keypress', '.ace_text-input', function(evt){
          evt.preventDefault(); // prevent Ace from doing further key event handling
        
          var input = String.fromCharCode(evt.which);
          var cursor = memGui.getCursorPosition();
          
          var cleanInput = input.replace(/[^A-Fa-f0-9]/g,'');
          if(cleanInput.length === 0)
            cleanInput = '0';
            
          var oldDoc = memGui.getValue();
          oldDoc = oldDoc.replace(/\n/g,''); // remove newlines if this is a multiline input
          
          var newDoc = stringSplice(oldDoc, (cursor.row*16)+cursor.column, 1, cleanInput);
          
          // Pad the edited doc with zeroes, to a multiple of 16 chars
          var newDocPadded = stringRPadToMultiple(newDoc, 16, '0');
          
          var newDocWrap = stringWrap(newDocPadded,16);
          
          memGui.setValue(newDocWrap, 1); // set the document text to the spliced string, and move the cursor to the end
          
          // Move the cursor to the new edit point
          
          memGui.clearSelection();
          if(cursor.column === 16){
            memGui.scrollToLine(cursor.row + 1)
            memGui.moveCursorTo(cursor.row+1, 1); // row, col
          }
          else {
            memGui.scrollToLine(cursor.row)
            memGui.moveCursorTo(cursor.row, cursor.column+1);
          }
          
          // Trigger a sync with the ASCII view, passing along info about this edit
          
          var cursorClone = $.extend({}, cursor);
          var hexStr = '';
          var hex = -1;
          
          if((cursor.row*16 + cursor.column) % 2 === 0){ // edited the lowest nybble of the byte
            hexStr = newDocPadded[cursor.row*16 + cursor.column] + newDocPadded[cursor.row*16 + cursor.column + 1];
          }
          else { // edited the highest nybble of the byte
            hexStr = newDocPadded[cursor.row*16 + cursor.column - 1] + newDocPadded[cursor.row*16 + cursor.column];
          }
          hex = parseInt(hexStr,16);
          
          $('#editor-mem-ascii').trigger('editor-sync', [cursorClone, hex]);
        });
        
        // ===
        
        // Modify the hex view when the ascii view changes
        $('#editor-mem').on('editor-sync', function(evt, cursor, charCode){
          // cursor = position of cursor before last edit
          var hexCol = cursor.column*2;
          
          var oldDoc = memGui.getValue();
          oldDoc = oldDoc.replace(/\n/g,''); // remove newlines if this is a multiline input
          
          // Convert character code to 2-character hex string
          var hex = charCode.toString(16);
          var cleanInput = ('00'+hex).substring(hex.length);
          
          // Insert hex in appropriate location, and pad the edited doc with filler char, to a multiple of 8 chars
          var newDoc = stringSplice(oldDoc, (cursor.row*16)+hexCol, 2, cleanInput);
          var newDocPadded = stringRPadToMultiple(newDoc, 16, '0');
          var newDocWrap = stringWrap(newDocPadded, 16);
          
          memGui.setValue(newDocWrap, 1); // set the document text to the spliced string, and move the cursor to the end
          
          // Move the cursor to the new edit point
          memGui.clearSelection();
          if(hexCol === 16){
            memGui.scrollToLine(cursor.row + 1)
            memGui.moveCursorTo(cursor.row+1, 2); // row, col
          }
          else {
            memGui.scrollToLine(cursor.row)
            memGui.moveCursorTo(cursor.row, hexCol+2);
          }
        });
        
        // Substitute chars invalid for ascii view, wrap ascii view to 8 columns
        $('#editor-mem-ascii').on('keypress', '.ace_text-input', function(evt){
          evt.preventDefault(); // prevent Ace from doing further key event handling
        
          var input = String.fromCharCode(evt.which);
          var cursor = asciiMemGui.getCursorPosition();
          
          var cleanInput = input.replace(/[^A-Za-z0-9 ]/g,'');
          if(cleanInput.length === 0)
            cleanInput = '.';
            
          var oldDoc = asciiMemGui.getValue();
          oldDoc = oldDoc.replace(/\n/g,''); // remove newlines if this is a multiline input
          
          var newDoc = stringSplice(oldDoc, (cursor.row*8)+cursor.column, 1, cleanInput);
          
          // Pad the edited doc with filler char, to a multiple of 8 chars
          var newDocPadded = stringRPadToMultiple(newDoc, 8, '.');
          var newDocWrap = stringWrap(newDocPadded,8);
          
          asciiMemGui.setValue(newDocWrap, 1); // set the document text to the spliced string, and move the cursor to the end
          
          // Move the cursor to the new edit point
          asciiMemGui.clearSelection();
          if(cursor.column === 8){
            asciiMemGui.scrollToLine(cursor.row + 1)
            asciiMemGui.moveCursorTo(cursor.row+1, 1); // row, col
          }
          else {
            asciiMemGui.scrollToLine(cursor.row)
            asciiMemGui.moveCursorTo(cursor.row, cursor.column+1);
          }
          
          // Trigger a sync with the hex view, passing along info about this edit
          var cursorClone = $.extend({}, cursor);
          var hex = cleanInput.charCodeAt(0);
          
          $('#editor-mem').trigger('editor-sync', [cursorClone, hex]);
        });
        
        // ===
        
        var curError = -1;
        
        $('table#assemble-output > tbody').on('mouseenter', 'tr', function(evt){
          var lineNo = parseInt($(this).children('th').text(), 10);
          var msg = $(this).children('td').text();
          
          curError = editor.getSession().addMarker(
            new Range(lineNo-1,0,lineNo,0), // start row, start column, end ...
            'assemble-error',
            'line'
          );
        });
        
        $('table#assemble-output > tbody').on('mouseleave', 'tr', function(evt){
          editor.getSession().removeMarker(curError);
        });
        
        // ===
      
        $('form#assemble').submit(function(evt){
          evt.preventDefault();
          $('table#assemble-output > tbody').empty(); // clear our table of errors from previous run
          
          var src = editor.getValue();
          
          // Assemble the program segment, load program & data segments into memory, and start execution
          try {
            var program = assemble(src); // returns an untyped array of natively-sized JS integers.
            var programLen = calcLen(program);
            
            // Load program segment into memory
            var programSegment = new DataView(Memory.bank, 0, programLen); // buffer, offset, length
            
            var byteI = 0;
            var hasImm = false;
            
            for(var i=0; i < program.length; i++){
              if(hasImm){
                programSegment.setInt16(byteI, program[i], false); // big endian
                byteI+=2;
                hasImm = false;
                continue;
              }

              switch(Instruction[program[i]]){
                case Instruction.IMM:
                case Instruction.JMP:
                case Instruction.BEQ:
                case Instruction.BNE:
                case Instruction.LOD:
                case Instruction.STO:
                  // multi-byte instructions
                  hasImm = true;
              }
              
              programSegment.setUint8(byteI, program[i]);
              byteI++;
            }
            
            // Append a data segment to memory
          }
          catch(e){          
            for(var i=0; i < e.length; i++){              
              var row = $('<tr></tr>');
              row.append('<th scope="row">'+e[i].lineNo+'</th>');
              row.append('<td>'+e[i].message+'</td>');
              
              $('table#assemble-output > tbody').append(row);
            }
          }
        });
      });
    </script>
  </body>
</html>
