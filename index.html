<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="shortcut icon" href="img/favicon.png">
    <title>JS Emulator</title>
    <!-- Bootstrap core CSS + customizations -->
    <link rel="stylesheet" type="text/css" href="index.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="bower_components/html5shiv/dist/html5shiv.js"></script>
    <script src="bower_components/respond/dest/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <section>
      <div class='container'>
        <div class='row'>
          <div class='col-md-12'>
            <h1 class='text-center'>Type assembly here:</h1>
            <form id="assemble">
              <div class="form-group">
                <textarea class="form-control" rows="10"></textarea>
                <p class="help-text">Assembler output will appear below.</p>
              </div>
              <button type="submit" class="btn btn-primary btn-block">Assemble</button>
            </form>
          </div>
        </div>
        <div class='row'>
          <div class='col-md-12'>
            <table class="table" id="assemble-output">
              <thead>
                <tr>
                  <th>Line #</th>
                  <th>Message</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
      </div>
    </section>
    <!-- Placed at the end of the document so the pages load faster -->
    <script type="text/javascript" src="bower_components/jquery/dist/jquery.js"></script>
    <script type="text/javascript" src="bower_components/bootstrap/dist/js/bootstrap.min.js"></script>
    <script>
      $(window).load(function() {
      
      });
      
      var Memory = {
        
      };
      
      var Instruction = {
        IMM: 0x00, // immediate
        ADD: 0x01,
        SUB: 0x02,
        MUL: 0x03,
        DIV: 0x04,
        JMP: 0x05, // absolute address ...
        BEQ: 0x06,
        BNE: 0x07,
        LOD: 0x08,
        STO: 0x09,
        // TODO PC relative addressing?
        NOP: 0xff
      };
      
      var VM = {
        stack: [],
        stackMax: 128,
        
        push: function(val){
          if(this.stack.length >= this.stackMax)
            throw new Error('Stack overflow!');
        
          this.stack.push(val & 0xff);
        },
        pop: function(){
          if(this.stack.length <= 0)
            throw new Error('Stack underflow!');
        
          var val = this.stack.pop();
          return (val & 0xff);
        },
        
        interpret: function(bytecode){
          var instruction, next;
          var lhs, rhs;
          
          for(var i=0; i < bytecode.length; i++){
            if(i < 0 || i >= bytecode.length)
              throw new Error('Segmentation fault!');
            
            // force all instructions to 1 byte
            instruction = bytecode[i] & 0xff;
            if((i+1) < bytecode.length)
              next = bytecode[i+1] & 0xff;
            else // must include else, so that previous 'next' val doesn't persist across instructions
              next = null;
            
            // check for well-formed instructions
            switch(instruction){
              case Instruction.IMM:
              case Instruction.JMP:
              case Instruction.BEQ:
              case Instruction.BNE:
              case Instruction.LOD:
              case Instruction.STO:
                if(next === null)
                  throw new Exception('Expected two-byte instruction!');
            }
            
            // execute instructions
            switch(instruction){
              default: // TODO must be at end of switch statement?
                throw new Exception('Unrecognized opcode!');
              case Instruction.NOP: 
                i++;
                break;
              case Instruction.IMM:
                this.push(next);
                i++;
                break;
              case Instruction.ADD:
                rhs = this.pop();
                lhs = this.pop();
                this.push(lhs + rhs);
                break;
              case Instruction.SUB:
                rhs = this.pop();
                lhs = this.pop();
                this.push(lhs - rhs);
                break;
              case Instruction.MUL:
                rhs = this.pop();
                lhs = this.pop();
                this.push(lhs * rhs);
                break;
              case Instruction.DIV:
                rhs = this.pop();
                lhs = this.pop();
                this.push(lhs / rhs);
                break;
              case Instruction.JMP:
                // addr = this.pop(); // would allow you to calculate jump addresses ... not needed
                i = next-1; // -1 since we're automatically incrementing i
                break;
              case Instruction.BEQ:
                rhs = this.pop();
                lhs = this.pop();
                if(lhs === rhs)
                  i = next-1;
                else
                  i++; // since we need to skip immediate value
                break;
              case Instruction.BNE:
                rhs = this.pop();
                lhs = this.pop();
                if(lhs !== rhs)
                  i = next-1; 
                else
                  i++;
                break;
              case Instruction.LOD:
                if(next < 0 || next >= bytecode.length) // check address since not using PC to access mem
                  throw new Error('Segmentation fault!');
                this.push(bytecode[next]);
                i++;
                break;
              case Instruction.STO:
                if(next < 0 || next >= bytecode.length) // check address since not using PC to access mem
                  throw new Error('Segmentation fault!');
                bytecode[next] = this.pop();
                i++;
                break;
            }
          }
        }
      };
      
      var AssembleError = function(lineNumber, msg){
        this.lineNo = lineNumber;
        this.message = msg;
      }
      AssembleError.prototype.toString = function(){
        return 'LINE <'+this.lineNo+'> '+this.message;
      };
      
      function assemble(src){
        var bin = [];
        var err = [];
      
        var lines = src.split('\n');
        var line, clean, mnemonic, immediate;
        
        for(var i=0; i < lines.length; i++){
          line = lines[i];
          clean = line.replace(/[^A-Za-z0-9- ]/g, '');
          clean = clean.trim();
        
          if(clean.length === 0) // ignore blank lines
            continue;
          if(clean.length === 3) {
            mnemonic = clean.toUpperCase(); // instruction mnemonic
            if(!(mnemonic in Instruction)){
              err.push(new AssembleError(i+1, 'Unknown opcode: "'+mnemonic+'".'));
              continue;
            }
          
            bin.push(Instruction[mnemonic]);
          }
          else {
            var tokens = /^([A-Za-z]{3})\s+(.*)$/g.exec(clean);
            
            if(tokens === null){
              err.push(new AssembleError(i+1, 'Bad instruction format: "'+line+'".'));
              continue;
            }

            // Check that the opcode actually exists
            mnemonic = tokens[1].toUpperCase();
            if(!(mnemonic in Instruction)){
              err.push(new AssembleError(i+1, 'Unknown opcode: "'+mnemonic+'".'));
              continue;
            }
            
            if(tokens[2].search(/^(-?0x[0-9A-Fa-f]+|-?\d+)$/g) === -1){
              err.push(new AssembleError(i+1, 'Bad immediate format: "'+tokens[2]+'".'));
              continue;
            }
          
            immediate = parseInt(tokens[2]);
            
            if(immediate < -128 || immediate > 127){
              err.push(new AssembleError(i+1, 'Immediate value will not fit in (signed) byte: "'+immediate+'".'));
              continue;
            }
            
            bin.push(Instruction[mnemonic]);
            bin.push(immediate);
          }
        }
        if(err.length !== 0)
          throw err;
          
        return bin;
      }
            
      $(document).ready(function(evt) {
        $('form#assemble').submit(function(evt){
          evt.preventDefault();
          $('table#assemble-output > tbody').empty(); // clear our table of errors from previous run
          
          var src = $(this).find('textarea').val();
          try {
            var bin = assemble(src);
            console.log(bin);
          }
          catch(e){
            for(var i=0; i < e.length; i++){              
              var row = $('<tr></tr>');
              row.append('<th scope="row">'+e[i].lineNo+'</th>');
              row.append('<td>'+e[i].message+'</td>');
              
              $('table#assemble-output > tbody').append(row);
            }
          }
        });
      });
    </script>
  </body>
</html>
